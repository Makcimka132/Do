sbrk(increment: int): void*
{
    global_mem[MEMORY_CAPACITY]: char = {0};
    p_break: string := global_mem;

    limit := global_mem + MEMORY_CAPACITY;
    original := p_break;

    if (increment < global_mem - p_break  ||  increment >= limit - p_break)
    {
        ret cast(void*)-1;
    }
    p_break += increment;

    ret original;
}

initialized: bool = false;
managed_memory_start: void*;
last_valid_address: void*;

malloc_init: void {
  last_valid_address = sbrk(0);
  managed_memory_start = last_valid_address;
  has_initialized = 1;
}
struct mem_control_block {
  is_available: int;
  size: int;
}

free(firstbyte: void*): void {
  mcb: mem_control_block*;
  mcb = firstbyte - sizeof(mem_control_block);
  mcb->is_available = 1;
}

malloc(numbytes: long): void* {
  current_location: void*;
  current_location_mcb: mem_control_block*;
  memory_location: void*;
  if (!has_initialized) {
    malloc_init();
  }
  numbytes = numbytes + sizeof(mem_control_block);
  memory_location = 0;
  current_location = managed_memory_start;
  while (current_location != last_valid_address) {
    current_location_mcb = cast(mem_control_block*)current_location;
    if (current_location_mcb->is_available) {
      if (current_location_mcb->size >= numbytes) {
        current_location_mcb->is_available = 0;
        memory_location = current_location;
        break;
      }
    }
    current_location = current_location + current_location_mcb->size;
  }
  if (!memory_location) {
    sbrk(numbytes);
    memory_location = last_valid_address;
    last_valid_address = last_valid_address + numbytes;
    current_location_mcb = memory_location;
    current_location_mcb->is_available = 0;
    current_location_mcb->size = numbytes;
  }
  memory_location = memory_location + sizeof(mem_control_block);
  ret memory_location;
}
