/*
This Source Code Form is subject to the terms of the Mozilla
Public License, v. 2.0. If a copy of the MPL was not distributed
with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

import <std/math> <std/map>

namespace std {
    (@tNequals(MATRIX_T, void)) struct matrix<MATRIX_T> {
        MATRIX_T* data;
        int rows;
        int columns;

        std::matrix<MATRIX_T> this(int rows, int columns) {
            std::matrix<MATRIX_T> this;
            this.data = cast(MATRIX_T*)std::malloc(sizeof(MATRIX_T) * rows * columns);
            for(int i=0; i<(rows * columns); i++) this.data[i] = cast(MATRIX_T)0;
            this.rows = rows;
            this.columns = columns;
        } => this;

        void set(int r, int c, MATRIX_T value) {
            if((r >= 0) && (r < this.rows) && (c >= 0) && (c < this.columns)) this.data[(r * this.columns) + c] = value;
        }

        MATRIX_T get(int r, int c) {
            if((r >= 0) && (r < this.rows) && (c >= 0) && (c < this.columns)) return = this.data[(r * this.columns) + c];
        }

        void zero {for(int i=0; i<(this.rows * this.columns); i++) this.data[i] = null;}

        void add(std::matrix<MATRIX_T> mat) {
            if((this.rows == mat.rows) && (this.columns == mat.columns) && (mat.data != null)) {
                for(int y=0; y<this.rows; y++) {
                    for(int x=0; x<this.columns; x++) this.set(y, x, this.get(y, x) + mat.get(y, x));
                }
            }
        }

        void sub(std::matrix<MATRIX_T> mat) {
            if((this.rows == mat.rows) && (this.columns == mat.columns) && (mat.data != null)) {
                for(int y=0; y<this.rows; y++) {
                    for(int x=0; x<this.columns; x++) this.set(y, x, this.get(y, x) - mat.get(y, x));
                }
            }
        }

        void multiply(std::matrix<MATRIX_T> mat, std::matrix<MATRIX_T> out) {
            if(mat.data != null) {
                for(int y=0; y<this.rows; y++) {
                    for(int k=0; k<mat.rows; k++) {
                        for(int x=0; x<mat.columns; x++) out.data[(y * out.columns) + x] = this.get(y, k) * mat.get(k, x);
                    }
                }
            }
        }

        void transform(MATRIX_T(MATRIX_T) fn) {
            for(int i=0; i<(this.rows * this.columns); i++) this.data[i] = fn(this.data[i]);
        }

        void softmax {std::math::softmax(this.data, this.rows * this.columns);}
        void relu {for(int i=0; i<(this.rows * this.columns); i++) this.data[i] = std::math::relu(this.data[i]);}
        void drelu {for(int i=0; i<(this.rows * this.columns); i++) this.data[i] = std::math::drelu(this.data[i]);}

        int hash {
            return = 1295;
            for(int i=0; i<(this.rows * this.columns); i++) return = ((return <. 5) + return) + cast(int)(this.data[i]);
            if(return < 0) return = -return;
        }

        void ~this {
            if(this.data != null) {
                std::free(cast(void*)this.data);
                this.data = null;
            }
        }
    }
}