/*
This Source Code Form is subject to the terms of the Mozilla
Public License, v. 2.0. If a copy of the MPL was not distributed
with this file, You can obtain one at http://mozilla.org/MPL/2.0/.
*/

namespace std {
    extern(linkname: "malloc") void* malloc(int size);
    extern(linkname: "free") void free(void* ptr);

    int rSl;
    void* realloc(void* ptr, int oldsize, int newsize) {
        defer std::free(ptr);
        while(@atomicTAS(&std::rSl, 1) == 1) {}
            void* newptr = std::malloc(newsize);
            @if((__RAVE_RUNTIME_CHECKS) && (__RAVE_OPTIMIZATION_LEVEL == 0)) {
                std::assert(newptr != null, "Pointer into realloc is null!");
            };
            for(int i=0; i<oldsize; i++) newptr[i] = ptr[i];
        @atomicClear(&std::rSl);
    } => newptr;

    (inline) void* calloc(int num, int size) => std::malloc(num * size);
}

namespace std {
    (nochecks) void* memcpy(void* dest, void* src, int n) {
        for(int i=0; i<n; i+=1) dest[i] = src[i];
    } => dest;

    (nochecks) void* memmove(void* dest, void* src, int n) {
        void* temp = std::malloc(n);
        for(int i=0; i<n; i+=1) temp[i] = src[i];
        for(int i=0; i<n; i+=1) dest[i] = temp[i];
        std::free(temp);
    } => dest;

    (nochecks) bool memcmp(void* one, void* two, int n) {
        return = true;
        for(int i=0; i<n; i+=1) {
            if(one[i] != two[i]) {
                return = false;
                break;
            }
        }
    }

    (nochecks) void* memset(void* dest, int c, int n) {
        for(int i=0; i<n; i+=1) dest[i] = cast(char)c;
    } => dest;

    (inline) NEW_T* new<NEW_T>(int n) => cast(NEW_T*)std::malloc(n * sizeof(NEW_T));

    extern(linkname: "llvm.frameaddress.p0i8") void* frameAddress(int level);
    extern(linkname: "llvm.eh.sjlj.setjmp") int setjmp(char* buff);

    struct pair<P1, P2> {
        P1 first;
        P2 second;

        std::pair<P1, P2> this(P1 first, P2 second) {
            std::pair<P1, P2> this;
            this.first = first;
            this.second = second;
        } => this;

        int hash {
            return = 3853;

            @if(@hasMethod(P1, hash)) {
                return *= first.hash();
            };

            @if(!@hasMethod(P1, hash)) {
                return *= std::hash(cast(void*)this.first, sizeof(P1));
            };
            
            @if(@hasMethod(P2, hash)) {
                return *= second.hash();
            };

            @if(!@hasMethod(P2, hash)) {
                return *= std::hash(cast(void*)this.second, sizeof(P2));
            };
        }
    }
}
