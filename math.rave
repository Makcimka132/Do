import <std/vector>

namespace std {
  namespace math {
    alias PI = 3.14159265358979323846;

    (inline) float degToRad(float d) => d * std::math::PI / 180;
    (inline) float radToDeg(float r) => r * 180 / std::math::PI;

    int factorial(int n) {
        int fact = 1;
        int i = 1;
        while(i <= n) {
            fact = fact * i;
            i += 1;
        }
    } => fact;

    extern(linkname: "lroundf") long round(float f);
    extern(linkname: "acosf") float acos(float f);
    extern(linkname: "acoshf") float acosh(float f);
    extern(linkname: "asinf") float asin(float f);
    extern(linkname: "asinhf") float asinh(float f);
    extern(linkname: "atanf") float atan(float f);
    extern(linkname: "atanhf") float atanh(float f);
    extern(linkname: "cbrtf") float cbrt(float f);
    extern(linkname: "ceilf") float ceil(float f);
    extern(linkname: "coshf") float cosh(float f);
    extern(linkname: "erff") float erf(float f);
    extern(linkname: "exp2") float exp2(float f);
    float floor(float f) {
        float tmp = (cast(float)(cast(long)f));
        if(tmp < 0) tmp = tmp - 1.0;
    } => tmp;
    float fmin(float one, float two) {
        float result = one;
        if(one > two) result = two;
    } => result;
    float fmax(float one, float two) {
        float result = one;
        if(one < two) result = two;
    } => result;
    extern(linkname: "fmodf") float fmod(float x, float y);
    extern(linkname: "sinf") float sin(float f);
    extern(linkname: "sqrtf") float sqrt(float f);
    extern(linkname: "powf") float pow(float f1, float f2);
    float trunc(float f) => cast(float)(cast(long)f);

    bool isPrime(int number) {
        bool toret = true;
        int i = 2;

        bool active = true;
        while((i<number) && active) {
            if((number % i == 0) && (i != number)) {
                toret = false;
                active = false;
            }
            i += 1;
        }
    } => toret;

    int nextPrime(int number) {
        int n = number;
        while(!(std::math::isPrime(n))) n += 1;
    } => n;

    /*
    TODO patch for <0 and >90 deg
    */
    @warning("std::math::cos is experimental, and values above 90deg and below 0deg may not work correctly.")
    float cos(float f)
    {
        float result = 0.0;
        int n = 0;
        int precision = 10;
        while(n < precision)
        {
            result += (std::math::pow(-1.0, cast(float)n)*std::math::pow(f, cast(float)2*n))/std::math::factorial(2*n);
            n += 1;
        }
        
    } => result;
  }
}